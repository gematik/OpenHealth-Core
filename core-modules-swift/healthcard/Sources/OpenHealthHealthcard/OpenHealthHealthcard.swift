// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(OpenHealthHealthcardFFI)
import OpenHealthHealthcardFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_healthcard_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_healthcard_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        self.init(
            bytesNoCopy: rustBuffer.data!,
            count: Int(rustBuffer.len),
            deallocator: .none
        )
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureHealthcardInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
// Initial value and increment amount for handles. 
// These ensure that SWIFT handles always have the lowest bit set
fileprivate let UNIFFI_HANDLEMAP_INITIAL: UInt64 = 1
fileprivate let UNIFFI_HANDLEMAP_DELTA: UInt64 = 2

fileprivate final class UniffiHandleMap<T>: @unchecked Sendable {
    // All mutation happens with this lock held, which is why we implement @unchecked Sendable.
    private let lock = NSLock()
    private var map: [UInt64: T] = [:]
    private var currentHandle: UInt64 = UNIFFI_HANDLEMAP_INITIAL

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            return doInsert(obj)
        }
    }

    // Low-level insert function, this assumes `lock` is held.
    private func doInsert(_ obj: T) -> UInt64 {
        let handle = currentHandle
        currentHandle += UNIFFI_HANDLEMAP_DELTA
        map[handle] = obj
        return handle
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

     func clone(handle: UInt64) throws -> UInt64 {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return doInsert(obj)
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.
// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return Data(try readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}




/**
 * Card Access Number (CAN) used during PACE establishment.
 */
public protocol CardAccessNumberProtocol: AnyObject, Sendable {
    
    /**
     * Returns the CAN digits as a string.
     */
    func digits()  -> String
    
}
/**
 * Card Access Number (CAN) used during PACE establishment.
 */
open class CardAccessNumber: CardAccessNumberProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_healthcard_fn_clone_cardaccessnumber(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        try! rustCall { uniffi_healthcard_fn_free_cardaccessnumber(handle, $0) }
    }

    
    /**
     * Creates a CAN from a 6-digit string (e.g. `"123456"`).
     */
public static func fromDigits(digits: String)throws  -> CardAccessNumber  {
    return try  FfiConverterTypeCardAccessNumber_lift(try rustCallWithError(FfiConverterTypeSecureChannelError_lift) {
    uniffi_healthcard_fn_constructor_cardaccessnumber_from_digits(
        FfiConverterString.lower(digits),$0
    )
})
}
    

    
    /**
     * Returns the CAN digits as a string.
     */
open func digits() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_healthcard_fn_method_cardaccessnumber_digits(
            self.uniffiCloneHandle(),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCardAccessNumber: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = CardAccessNumber

    public static func lift(_ handle: UInt64) throws -> CardAccessNumber {
        return CardAccessNumber(unsafeFromHandle: handle)
    }

    public static func lower(_ value: CardAccessNumber) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CardAccessNumber {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: CardAccessNumber, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCardAccessNumber_lift(_ handle: UInt64) throws -> CardAccessNumber {
    return try FfiConverterTypeCardAccessNumber.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCardAccessNumber_lower(_ value: CardAccessNumber) -> UInt64 {
    return FfiConverterTypeCardAccessNumber.lower(value)
}






/**
 * Card channel interface to be implemented by the host application.
 *
 * A `CardChannel` represents an established connection/session to a smart card reader and is the
 * transport layer used by this library to exchange APDUs with the card.
 *
 * Implementations must be thread-safe (`Send + Sync`). Calls from this library are serialized,
 * but they may come from different threads.
 */
public protocol CardChannel: AnyObject, Sendable {
    
    /**
     * Whether the underlying reader/session supports extended-length APDUs.
     *
     * Returning `false` forces the library to use short-length encoding, which may prevent
     * certain commands from being sent if they exceed short-length limits.
     */
    func supportsExtendedLength()  -> Bool
    
    /**
     * Transmits `command` to the card and returns the response APDU.
     *
     * The returned `ResponseApdu` must include the status word (SW1SW2). If the reader API
     * returns raw bytes, use `ResponseApdu::from_bytes`.
     */
    func transmit(command: CommandApdu) throws  -> ResponseApdu
    
}
/**
 * Card channel interface to be implemented by the host application.
 *
 * A `CardChannel` represents an established connection/session to a smart card reader and is the
 * transport layer used by this library to exchange APDUs with the card.
 *
 * Implementations must be thread-safe (`Send + Sync`). Calls from this library are serialized,
 * but they may come from different threads.
 */
open class CardChannelImpl: CardChannel, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_healthcard_fn_clone_cardchannel(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        try! rustCall { uniffi_healthcard_fn_free_cardchannel(handle, $0) }
    }

    

    
    /**
     * Whether the underlying reader/session supports extended-length APDUs.
     *
     * Returning `false` forces the library to use short-length encoding, which may prevent
     * certain commands from being sent if they exceed short-length limits.
     */
open func supportsExtendedLength() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_healthcard_fn_method_cardchannel_supports_extended_length(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Transmits `command` to the card and returns the response APDU.
     *
     * The returned `ResponseApdu` must include the status word (SW1SW2). If the reader API
     * returns raw bytes, use `ResponseApdu::from_bytes`.
     */
open func transmit(command: CommandApdu)throws  -> ResponseApdu  {
    return try  FfiConverterTypeResponseApdu_lift(try rustCallWithError(FfiConverterTypeCardChannelError_lift) {
    uniffi_healthcard_fn_method_cardchannel_transmit(
            self.uniffiCloneHandle(),
        FfiConverterTypeCommandApdu_lower(command),$0
    )
})
}
    

    
}



// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceCardChannel {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceCardChannel] = [UniffiVTableCallbackInterfaceCardChannel(
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            do {
                try FfiConverterTypeCardChannel.handleMap.remove(handle: uniffiHandle)
            } catch {
                print("Uniffi callback interface CardChannel: handle missing in uniffiFree")
            }
        },
        uniffiClone: { (uniffiHandle: UInt64) -> UInt64 in
            do {
                return try FfiConverterTypeCardChannel.handleMap.clone(handle: uniffiHandle)
            } catch {
                fatalError("Uniffi callback interface CardChannel: handle missing in uniffiClone")
            }
        },
        supportsExtendedLength: { (
            uniffiHandle: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<Int8>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> Bool in
                guard let uniffiObj = try? FfiConverterTypeCardChannel.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.supportsExtendedLength(
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterBool.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        transmit: { (
            uniffiHandle: UInt64,
            command: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UInt64>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> ResponseApdu in
                guard let uniffiObj = try? FfiConverterTypeCardChannel.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.transmit(
                     command: try FfiConverterTypeCommandApdu_lift(command)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterTypeResponseApdu_lower($0) }
            uniffiTraitInterfaceCallWithError(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn,
                lowerError: FfiConverterTypeCardChannelError_lower
            )
        }
    )]
}

private func uniffiCallbackInitCardChannel() {
    uniffi_healthcard_fn_init_callback_vtable_cardchannel(UniffiCallbackInterfaceCardChannel.vtable)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCardChannel: FfiConverter {
    fileprivate static let handleMap = UniffiHandleMap<CardChannel>()

    typealias FfiType = UInt64
    typealias SwiftType = CardChannel

    public static func lift(_ handle: UInt64) throws -> CardChannel {
        if ((handle & 1) == 0) {
            // Rust-generated handle, construct a new class that uses the handle to implement the
            // interface
            return CardChannelImpl(unsafeFromHandle: handle)
        } else {
            // Swift-generated handle, get the object from the handle map
            return try handleMap.remove(handle: handle)
        }
    }

    public static func lower(_ value: CardChannel) -> UInt64 {
         if let rustImpl = value as? CardChannelImpl {
             // Rust-implemented object.  Clone the handle and return it
            return rustImpl.uniffiCloneHandle()
         } else {
            // Swift object, generate a new vtable handle and return that.
            return handleMap.insert(obj: value)
         }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CardChannel {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: CardChannel, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCardChannel_lift(_ handle: UInt64) throws -> CardChannel {
    return try FfiConverterTypeCardChannel.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCardChannel_lower(_ value: CardChannel) -> UInt64 {
    return FfiConverterTypeCardChannel.lower(value)
}






/**
 * PIN/secret value used for card operations.
 *
 * The input string is zeroized after parsing. Treat PIN values and derived data as secrets.
 */
public protocol CardPinProtocol: AnyObject, Sendable {
    
}
/**
 * PIN/secret value used for card operations.
 *
 * The input string is zeroized after parsing. Treat PIN values and derived data as secrets.
 */
open class CardPin: CardPinProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_healthcard_fn_clone_cardpin(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        try! rustCall { uniffi_healthcard_fn_free_cardpin(handle, $0) }
    }

    
    /**
     * Creates a PIN from a digit string (e.g. `"123456"`).
     *
     * The provided string is zeroized in memory after parsing.
     */
public static func fromDigits(digits: String)throws  -> CardPin  {
    return try  FfiConverterTypeCardPin_lift(try rustCallWithError(FfiConverterTypeExchangeError_lift) {
    uniffi_healthcard_fn_constructor_cardpin_from_digits(
        FfiConverterString.lower(digits),$0
    )
})
}
    

    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCardPin: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = CardPin

    public static func lift(_ handle: UInt64) throws -> CardPin {
        return CardPin(unsafeFromHandle: handle)
    }

    public static func lower(_ value: CardPin) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CardPin {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: CardPin, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCardPin_lift(_ handle: UInt64) throws -> CardPin {
    return try FfiConverterTypeCardPin.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCardPin_lower(_ value: CardPin) -> UInt64 {
    return FfiConverterTypeCardPin.lower(value)
}






/**
 * ISO/IEC 7816-4 command APDU.
 *
 * Length parameters are expressed as `u32`. Values outside the supported APDU ranges return
 * `ApduError::InvalidLength`.
 */
public protocol CommandApduProtocol: AnyObject, Sendable {
    
    /**
     * Serializes the command APDU to raw bytes.
     */
    func toBytes()  -> Data
    
}
/**
 * ISO/IEC 7816-4 command APDU.
 *
 * Length parameters are expressed as `u32`. Values outside the supported APDU ranges return
 * `ApduError::InvalidLength`.
 */
open class CommandApdu: CommandApduProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_healthcard_fn_clone_commandapdu(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        try! rustCall { uniffi_healthcard_fn_free_commandapdu(handle, $0) }
    }

    
    /**
     * Parses a command APDU from raw bytes.
     */
public static func fromBytes(bytes: Data)throws  -> CommandApdu  {
    return try  FfiConverterTypeCommandApdu_lift(try rustCallWithError(FfiConverterTypeApduError_lift) {
    uniffi_healthcard_fn_constructor_commandapdu_from_bytes(
        FfiConverterData.lower(bytes),$0
    )
})
}
    
    /**
     * Creates a case 1 APDU (header only, no data, no expected length).
     */
public static func headerOnly(cla: UInt8, ins: UInt8, p1: UInt8, p2: UInt8)throws  -> CommandApdu  {
    return try  FfiConverterTypeCommandApdu_lift(try rustCallWithError(FfiConverterTypeApduError_lift) {
    uniffi_healthcard_fn_constructor_commandapdu_header_only(
        FfiConverterUInt8.lower(cla),
        FfiConverterUInt8.lower(ins),
        FfiConverterUInt8.lower(p1),
        FfiConverterUInt8.lower(p2),$0
    )
})
}
    
    /**
     * Creates an APDU with command data (`Lc` + data), without an expected response length.
     *
     * `length_class` selects short or extended-length encoding and therefore constrains `data`
     * length (short: `1..=255`, extended: `>= 256`).
     */
public static func withData(cla: UInt8, ins: UInt8, p1: UInt8, p2: UInt8, lengthClass: LengthClass, data: Data)throws  -> CommandApdu  {
    return try  FfiConverterTypeCommandApdu_lift(try rustCallWithError(FfiConverterTypeApduError_lift) {
    uniffi_healthcard_fn_constructor_commandapdu_with_data(
        FfiConverterUInt8.lower(cla),
        FfiConverterUInt8.lower(ins),
        FfiConverterUInt8.lower(p1),
        FfiConverterUInt8.lower(p2),
        FfiConverterTypeLengthClass_lower(lengthClass),
        FfiConverterData.lower(data),$0
    )
})
}
    
    /**
     * Creates an APDU with command data (`Lc` + data) and an expected response length (`Le`).
     *
     * See `with_expect` for the valid `expected_length` ranges.
     */
public static func withDataAndExpect(cla: UInt8, ins: UInt8, p1: UInt8, p2: UInt8, lengthClass: LengthClass, data: Data, expectedLength: UInt32)throws  -> CommandApdu  {
    return try  FfiConverterTypeCommandApdu_lift(try rustCallWithError(FfiConverterTypeApduError_lift) {
    uniffi_healthcard_fn_constructor_commandapdu_with_data_and_expect(
        FfiConverterUInt8.lower(cla),
        FfiConverterUInt8.lower(ins),
        FfiConverterUInt8.lower(p1),
        FfiConverterUInt8.lower(p2),
        FfiConverterTypeLengthClass_lower(lengthClass),
        FfiConverterData.lower(data),
        FfiConverterUInt32.lower(expectedLength),$0
    )
})
}
    
    /**
     * Creates an APDU with an expected response length (`Le`).
     *
     * `expected_length` is the expected number of response bytes (excluding SW1SW2).
     *
     * Special values:
     * - With `length_class = Short`, `expected_length` must be in `0..=256`.
     * - `expected_length = 0` or `256` requests the maximum short-length response (`Le = 0x00`).
     * - With `length_class = Extended`, `expected_length` must be in `257..=65536`.
     * - `expected_length = 65536` requests the maximum extended-length response (`Le = 0x0000`).
     */
public static func withExpect(cla: UInt8, ins: UInt8, p1: UInt8, p2: UInt8, lengthClass: LengthClass, expectedLength: UInt32)throws  -> CommandApdu  {
    return try  FfiConverterTypeCommandApdu_lift(try rustCallWithError(FfiConverterTypeApduError_lift) {
    uniffi_healthcard_fn_constructor_commandapdu_with_expect(
        FfiConverterUInt8.lower(cla),
        FfiConverterUInt8.lower(ins),
        FfiConverterUInt8.lower(p1),
        FfiConverterUInt8.lower(p2),
        FfiConverterTypeLengthClass_lower(lengthClass),
        FfiConverterUInt32.lower(expectedLength),$0
    )
})
}
    

    
    /**
     * Serializes the command APDU to raw bytes.
     */
open func toBytes() -> Data  {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_healthcard_fn_method_commandapdu_to_bytes(
            self.uniffiCloneHandle(),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCommandApdu: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = CommandApdu

    public static func lift(_ handle: UInt64) throws -> CommandApdu {
        return CommandApdu(unsafeFromHandle: handle)
    }

    public static func lower(_ value: CommandApdu) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CommandApdu {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: CommandApdu, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCommandApdu_lift(_ handle: UInt64) throws -> CommandApdu {
    return try FfiConverterTypeCommandApdu.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCommandApdu_lower(_ value: CommandApdu) -> UInt64 {
    return FfiConverterTypeCommandApdu.lower(value)
}






/**
 * ISO/IEC 7816-4 response APDU.
 *
 * This object represents a response APDU and exposes:
 * - `sw()`: status word (SW1SW2)
 * - `data()`: response data without the status word
 * - `to_bytes()`: raw APDU bytes (`data || SW1 || SW2`)
 */
public protocol ResponseApduProtocol: AnyObject, Sendable {
    
    /**
     * Returns the response data (without SW1SW2).
     */
    func data()  -> Data
    
    /**
     * Returns the status word (SW1SW2) as `0xSW1SW2` (big-endian).
     */
    func sw()  -> UInt16
    
    /**
     * Serializes the response APDU to raw bytes (`data || SW1 || SW2`).
     */
    func toBytes()  -> Data
    
}
/**
 * ISO/IEC 7816-4 response APDU.
 *
 * This object represents a response APDU and exposes:
 * - `sw()`: status word (SW1SW2)
 * - `data()`: response data without the status word
 * - `to_bytes()`: raw APDU bytes (`data || SW1 || SW2`)
 */
open class ResponseApdu: ResponseApduProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_healthcard_fn_clone_responseapdu(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        try! rustCall { uniffi_healthcard_fn_free_responseapdu(handle, $0) }
    }

    
    /**
     * Parses a response APDU from raw bytes.
     *
     * The input must contain at least SW1SW2 (2 bytes).
     */
public static func fromBytes(bytes: Data)throws  -> ResponseApdu  {
    return try  FfiConverterTypeResponseApdu_lift(try rustCallWithError(FfiConverterTypeApduError_lift) {
    uniffi_healthcard_fn_constructor_responseapdu_from_bytes(
        FfiConverterData.lower(bytes),$0
    )
})
}
    
    /**
     * Creates a response APDU from `sw` (SW1SW2) and response `data`.
     *
     * `sw` is interpreted as big-endian (SW1<<8 | SW2).
     */
public static func fromParts(sw: UInt16, data: Data)throws  -> ResponseApdu  {
    return try  FfiConverterTypeResponseApdu_lift(try rustCallWithError(FfiConverterTypeApduError_lift) {
    uniffi_healthcard_fn_constructor_responseapdu_from_parts(
        FfiConverterUInt16.lower(sw),
        FfiConverterData.lower(data),$0
    )
})
}
    

    
    /**
     * Returns the response data (without SW1SW2).
     */
open func data() -> Data  {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_healthcard_fn_method_responseapdu_data(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Returns the status word (SW1SW2) as `0xSW1SW2` (big-endian).
     */
open func sw() -> UInt16  {
    return try!  FfiConverterUInt16.lift(try! rustCall() {
    uniffi_healthcard_fn_method_responseapdu_sw(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Serializes the response APDU to raw bytes (`data || SW1 || SW2`).
     */
open func toBytes() -> Data  {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_healthcard_fn_method_responseapdu_to_bytes(
            self.uniffiCloneHandle(),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeResponseApdu: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = ResponseApdu

    public static func lift(_ handle: UInt64) throws -> ResponseApdu {
        return ResponseApdu(unsafeFromHandle: handle)
    }

    public static func lower(_ value: ResponseApdu) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResponseApdu {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: ResponseApdu, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeResponseApdu_lift(_ handle: UInt64) throws -> ResponseApdu {
    return try FfiConverterTypeResponseApdu.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeResponseApdu_lower(_ value: ResponseApdu) -> UInt64 {
    return FfiConverterTypeResponseApdu.lower(value)
}






/**
 * Established secure messaging context (PACE + mutual authentication).
 *
 * This object wraps a core `SecureChannel` and uses a mutex to serialize access.
 * Use it for repeated operations after PACE establishment.
 */
public protocol SecureChannelProtocol: AnyObject, Sendable {
    
    /**
     * Changes the home PIN using the old PIN.
     */
    func changePin(oldPin: CardPin, newPin: CardPin) throws  -> HealthCardResponseStatus
    
    /**
     * Changes the home PIN using the PUK (reset retry counter + new PIN).
     */
    func changePinWithPuk(puk: CardPin, newPin: CardPin) throws  -> HealthCardResponseStatus
    
    /**
     * Returns `length` bytes of random data from the card.
     */
    func getRandom(length: UInt32) throws  -> Data
    
    /**
     * Reads the VSD container from the card (if available).
     */
    func readVsd() throws  -> Data
    
    /**
     * Retrieves the default certificate from the card.
     */
    func retrieveCertificate() throws  -> Data
    
    /**
     * Retrieves a specific certificate file from the card.
     */
    func retrieveCertificateFrom(certificate: CertificateFile) throws  -> Data
    
    /**
     * Signs the given challenge with the card's signing key.
     */
    func signChallenge(challenge: Data) throws  -> Data
    
    /**
     * Indicates whether the underlying channel supports extended-length APDUs.
     */
    func supportsExtendedLength()  -> Bool
    
    /**
     * Transmits a raw command APDU through the secure channel and returns a response APDU.
     */
    func transmit(command: CommandApdu) throws  -> ResponseApdu
    
    /**
     * Unlocks the home PIN using the PUK (reset retry counter).
     */
    func unlockEgkWithPuk(puk: CardPin) throws  -> HealthCardResponseStatus
    
    /**
     * Verifies a PIN using the secure messaging context.
     */
    func verifyPin(pin: CardPin) throws  -> VerifyPinResult
    
}
/**
 * Established secure messaging context (PACE + mutual authentication).
 *
 * This object wraps a core `SecureChannel` and uses a mutex to serialize access.
 * Use it for repeated operations after PACE establishment.
 */
open class SecureChannel: SecureChannelProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_healthcard_fn_clone_securechannel(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        try! rustCall { uniffi_healthcard_fn_free_securechannel(handle, $0) }
    }

    

    
    /**
     * Changes the home PIN using the old PIN.
     */
open func changePin(oldPin: CardPin, newPin: CardPin)throws  -> HealthCardResponseStatus  {
    return try  FfiConverterTypeHealthCardResponseStatus_lift(try rustCallWithError(FfiConverterTypeSecureChannelError_lift) {
    uniffi_healthcard_fn_method_securechannel_change_pin(
            self.uniffiCloneHandle(),
        FfiConverterTypeCardPin_lower(oldPin),
        FfiConverterTypeCardPin_lower(newPin),$0
    )
})
}
    
    /**
     * Changes the home PIN using the PUK (reset retry counter + new PIN).
     */
open func changePinWithPuk(puk: CardPin, newPin: CardPin)throws  -> HealthCardResponseStatus  {
    return try  FfiConverterTypeHealthCardResponseStatus_lift(try rustCallWithError(FfiConverterTypeSecureChannelError_lift) {
    uniffi_healthcard_fn_method_securechannel_change_pin_with_puk(
            self.uniffiCloneHandle(),
        FfiConverterTypeCardPin_lower(puk),
        FfiConverterTypeCardPin_lower(newPin),$0
    )
})
}
    
    /**
     * Returns `length` bytes of random data from the card.
     */
open func getRandom(length: UInt32)throws  -> Data  {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypeSecureChannelError_lift) {
    uniffi_healthcard_fn_method_securechannel_get_random(
            self.uniffiCloneHandle(),
        FfiConverterUInt32.lower(length),$0
    )
})
}
    
    /**
     * Reads the VSD container from the card (if available).
     */
open func readVsd()throws  -> Data  {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypeSecureChannelError_lift) {
    uniffi_healthcard_fn_method_securechannel_read_vsd(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Retrieves the default certificate from the card.
     */
open func retrieveCertificate()throws  -> Data  {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypeSecureChannelError_lift) {
    uniffi_healthcard_fn_method_securechannel_retrieve_certificate(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Retrieves a specific certificate file from the card.
     */
open func retrieveCertificateFrom(certificate: CertificateFile)throws  -> Data  {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypeSecureChannelError_lift) {
    uniffi_healthcard_fn_method_securechannel_retrieve_certificate_from(
            self.uniffiCloneHandle(),
        FfiConverterTypeCertificateFile_lower(certificate),$0
    )
})
}
    
    /**
     * Signs the given challenge with the card's signing key.
     */
open func signChallenge(challenge: Data)throws  -> Data  {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypeSecureChannelError_lift) {
    uniffi_healthcard_fn_method_securechannel_sign_challenge(
            self.uniffiCloneHandle(),
        FfiConverterData.lower(challenge),$0
    )
})
}
    
    /**
     * Indicates whether the underlying channel supports extended-length APDUs.
     */
open func supportsExtendedLength() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_healthcard_fn_method_securechannel_supports_extended_length(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Transmits a raw command APDU through the secure channel and returns a response APDU.
     */
open func transmit(command: CommandApdu)throws  -> ResponseApdu  {
    return try  FfiConverterTypeResponseApdu_lift(try rustCallWithError(FfiConverterTypeSecureChannelError_lift) {
    uniffi_healthcard_fn_method_securechannel_transmit(
            self.uniffiCloneHandle(),
        FfiConverterTypeCommandApdu_lower(command),$0
    )
})
}
    
    /**
     * Unlocks the home PIN using the PUK (reset retry counter).
     */
open func unlockEgkWithPuk(puk: CardPin)throws  -> HealthCardResponseStatus  {
    return try  FfiConverterTypeHealthCardResponseStatus_lift(try rustCallWithError(FfiConverterTypeSecureChannelError_lift) {
    uniffi_healthcard_fn_method_securechannel_unlock_egk_with_puk(
            self.uniffiCloneHandle(),
        FfiConverterTypeCardPin_lower(puk),$0
    )
})
}
    
    /**
     * Verifies a PIN using the secure messaging context.
     */
open func verifyPin(pin: CardPin)throws  -> VerifyPinResult  {
    return try  FfiConverterTypeVerifyPinResult_lift(try rustCallWithError(FfiConverterTypeSecureChannelError_lift) {
    uniffi_healthcard_fn_method_securechannel_verify_pin(
            self.uniffiCloneHandle(),
        FfiConverterTypeCardPin_lower(pin),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSecureChannel: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = SecureChannel

    public static func lift(_ handle: UInt64) throws -> SecureChannel {
        return SecureChannel(unsafeFromHandle: handle)
    }

    public static func lower(_ value: SecureChannel) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecureChannel {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: SecureChannel, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecureChannel_lift(_ handle: UInt64) throws -> SecureChannel {
    return try FfiConverterTypeSecureChannel.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecureChannel_lower(_ value: SecureChannel) -> UInt64 {
    return FfiConverterTypeSecureChannel.lower(value)
}




/**
 * FFI-friendly response for health card commands.
 *
 * `status` is derived from `sw` and is suitable for application-level branching.
 */
public struct HealthCardResponse: Equatable, Hashable {
    public var status: HealthCardResponseStatus
    public var sw: UInt16
    public var data: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(status: HealthCardResponseStatus, sw: UInt16, data: Data) {
        self.status = status
        self.sw = sw
        self.data = data
    }

    
}

#if compiler(>=6)
extension HealthCardResponse: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHealthCardResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HealthCardResponse {
        return
            try HealthCardResponse(
                status: FfiConverterTypeHealthCardResponseStatus.read(from: &buf), 
                sw: FfiConverterUInt16.read(from: &buf), 
                data: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: HealthCardResponse, into buf: inout [UInt8]) {
        FfiConverterTypeHealthCardResponseStatus.write(value.status, into: &buf)
        FfiConverterUInt16.write(value.sw, into: &buf)
        FfiConverterData.write(value.data, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHealthCardResponse_lift(_ buf: RustBuffer) throws -> HealthCardResponse {
    return try FfiConverterTypeHealthCardResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHealthCardResponse_lower(_ value: HealthCardResponse) -> RustBuffer {
    return FfiConverterTypeHealthCardResponse.lower(value)
}


/**
 * Result for `verify_pin`, including outcome and (optional) remaining retries.
 */
public struct VerifyPinResult: Equatable, Hashable {
    public var outcome: VerifyPinOutcome
    public var response: HealthCardResponse
    public var retriesLeft: UInt8?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(outcome: VerifyPinOutcome, response: HealthCardResponse, retriesLeft: UInt8?) {
        self.outcome = outcome
        self.response = response
        self.retriesLeft = retriesLeft
    }

    
}

#if compiler(>=6)
extension VerifyPinResult: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeVerifyPinResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VerifyPinResult {
        return
            try VerifyPinResult(
                outcome: FfiConverterTypeVerifyPinOutcome.read(from: &buf), 
                response: FfiConverterTypeHealthCardResponse.read(from: &buf), 
                retriesLeft: FfiConverterOptionUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: VerifyPinResult, into buf: inout [UInt8]) {
        FfiConverterTypeVerifyPinOutcome.write(value.outcome, into: &buf)
        FfiConverterTypeHealthCardResponse.write(value.response, into: &buf)
        FfiConverterOptionUInt8.write(value.retriesLeft, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVerifyPinResult_lift(_ buf: RustBuffer) throws -> VerifyPinResult {
    return try FfiConverterTypeVerifyPinResult.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVerifyPinResult_lower(_ value: VerifyPinResult) -> RustBuffer {
    return FfiConverterTypeVerifyPinResult.lower(value)
}


public enum ApduError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    case InvalidHeader(String
    )
    case InvalidLength(String
    )
    case InvalidApdu(String
    )

    

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension ApduError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeApduError: FfiConverterRustBuffer {
    typealias SwiftType = ApduError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ApduError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidHeader(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .InvalidLength(
            try FfiConverterString.read(from: &buf)
            )
        case 3: return .InvalidApdu(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ApduError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .InvalidHeader(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .InvalidLength(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .InvalidApdu(v1):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeApduError_lift(_ buf: RustBuffer) throws -> ApduError {
    return try FfiConverterTypeApduError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeApduError_lower(_ value: ApduError) -> RustBuffer {
    return FfiConverterTypeApduError.lower(value)
}


/**
 * Error type returned by a `CardChannel` implementation.
 *
 * - Use `Transport` for I/O or reader/transport-level problems (timeouts, disconnected card, ...).
 * - Use `Apdu` if a response was received but it is not a valid response APDU.
 */
public enum CardChannelError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    /**
     * Transport/reader error.
     *
     * `code` is an implementation-defined numeric error code (e.g. a platform/reader API error)
     * and may be `0` if no specific code is available.
     */
    case Transport(code: UInt32, reason: String
    )
    /**
     * Invalid response APDU.
     */
    case Apdu(error: ApduError
    )

    

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension CardChannelError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCardChannelError: FfiConverterRustBuffer {
    typealias SwiftType = CardChannelError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CardChannelError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Transport(
            code: try FfiConverterUInt32.read(from: &buf), 
            reason: try FfiConverterString.read(from: &buf)
            )
        case 2: return .Apdu(
            error: try FfiConverterTypeApduError.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CardChannelError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Transport(code,reason):
            writeInt(&buf, Int32(1))
            FfiConverterUInt32.write(code, into: &buf)
            FfiConverterString.write(reason, into: &buf)
            
        
        case let .Apdu(error):
            writeInt(&buf, Int32(2))
            FfiConverterTypeApduError.write(error, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCardChannelError_lift(_ buf: RustBuffer) throws -> CardChannelError {
    return try FfiConverterTypeCardChannelError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCardChannelError_lower(_ value: CardChannelError) -> RustBuffer {
    return FfiConverterTypeCardChannelError.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Defines which certificate file to read from the card.
 */

public enum CertificateFile: Equatable, Hashable {
    
    /**
     * X.509 certificate stored in `DF.ESIGN/EF.C.CH.AUT.E256`.
     */
    case chAutE256
    /**
     * CV certificate stored in `MF/EF.C.eGK.AUT_CVC.E256`.
     */
    case egkAutCvcE256



}

#if compiler(>=6)
extension CertificateFile: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCertificateFile: FfiConverterRustBuffer {
    typealias SwiftType = CertificateFile

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CertificateFile {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .chAutE256
        
        case 2: return .egkAutCvcE256
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CertificateFile, into buf: inout [UInt8]) {
        switch value {
        
        
        case .chAutE256:
            writeInt(&buf, Int32(1))
        
        
        case .egkAutCvcE256:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCertificateFile_lift(_ buf: RustBuffer) throws -> CertificateFile {
    return try FfiConverterTypeCertificateFile.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCertificateFile_lower(_ value: CertificateFile) -> RustBuffer {
    return FfiConverterTypeCertificateFile.lower(value)
}



/**
 * UniFFI error type for exchange operations.
 *
 * This mirrors `crate::exchange::ExchangeError` but uses FFI-friendly payloads (strings/records).
 */
public enum ExchangeError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    case Transport(code: UInt32, reason: String
    )
    case UnexpectedStatus(status: HealthCardResponseStatus
    )
    case Status(status: HealthCardResponseStatus
    )
    case PaceInfo(reason: String
    )
    case Crypto(error: String
    )
    case Asn1Decode(reason: String
    )
    case Asn1Encode(reason: String
    )
    case GeneralAuthenticateCommand(reason: String
    )
    case ManageSecurityEnvironmentCommand(reason: String
    )
    case Command(reason: String
    )
    case PinBlock(reason: String
    )
    case InvalidCardVersion
    case InvalidArgument(reason: String
    )
    case MutualAuthenticationFailed
    case Apdu(error: ApduError
    )

    

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension ExchangeError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeExchangeError: FfiConverterRustBuffer {
    typealias SwiftType = ExchangeError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ExchangeError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Transport(
            code: try FfiConverterUInt32.read(from: &buf), 
            reason: try FfiConverterString.read(from: &buf)
            )
        case 2: return .UnexpectedStatus(
            status: try FfiConverterTypeHealthCardResponseStatus.read(from: &buf)
            )
        case 3: return .Status(
            status: try FfiConverterTypeHealthCardResponseStatus.read(from: &buf)
            )
        case 4: return .PaceInfo(
            reason: try FfiConverterString.read(from: &buf)
            )
        case 5: return .Crypto(
            error: try FfiConverterString.read(from: &buf)
            )
        case 6: return .Asn1Decode(
            reason: try FfiConverterString.read(from: &buf)
            )
        case 7: return .Asn1Encode(
            reason: try FfiConverterString.read(from: &buf)
            )
        case 8: return .GeneralAuthenticateCommand(
            reason: try FfiConverterString.read(from: &buf)
            )
        case 9: return .ManageSecurityEnvironmentCommand(
            reason: try FfiConverterString.read(from: &buf)
            )
        case 10: return .Command(
            reason: try FfiConverterString.read(from: &buf)
            )
        case 11: return .PinBlock(
            reason: try FfiConverterString.read(from: &buf)
            )
        case 12: return .InvalidCardVersion
        case 13: return .InvalidArgument(
            reason: try FfiConverterString.read(from: &buf)
            )
        case 14: return .MutualAuthenticationFailed
        case 15: return .Apdu(
            error: try FfiConverterTypeApduError.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ExchangeError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Transport(code,reason):
            writeInt(&buf, Int32(1))
            FfiConverterUInt32.write(code, into: &buf)
            FfiConverterString.write(reason, into: &buf)
            
        
        case let .UnexpectedStatus(status):
            writeInt(&buf, Int32(2))
            FfiConverterTypeHealthCardResponseStatus.write(status, into: &buf)
            
        
        case let .Status(status):
            writeInt(&buf, Int32(3))
            FfiConverterTypeHealthCardResponseStatus.write(status, into: &buf)
            
        
        case let .PaceInfo(reason):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(reason, into: &buf)
            
        
        case let .Crypto(error):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(error, into: &buf)
            
        
        case let .Asn1Decode(reason):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(reason, into: &buf)
            
        
        case let .Asn1Encode(reason):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(reason, into: &buf)
            
        
        case let .GeneralAuthenticateCommand(reason):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(reason, into: &buf)
            
        
        case let .ManageSecurityEnvironmentCommand(reason):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(reason, into: &buf)
            
        
        case let .Command(reason):
            writeInt(&buf, Int32(10))
            FfiConverterString.write(reason, into: &buf)
            
        
        case let .PinBlock(reason):
            writeInt(&buf, Int32(11))
            FfiConverterString.write(reason, into: &buf)
            
        
        case .InvalidCardVersion:
            writeInt(&buf, Int32(12))
        
        
        case let .InvalidArgument(reason):
            writeInt(&buf, Int32(13))
            FfiConverterString.write(reason, into: &buf)
            
        
        case .MutualAuthenticationFailed:
            writeInt(&buf, Int32(14))
        
        
        case let .Apdu(error):
            writeInt(&buf, Int32(15))
            FfiConverterTypeApduError.write(error, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExchangeError_lift(_ buf: RustBuffer) throws -> ExchangeError {
    return try FfiConverterTypeExchangeError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExchangeError_lower(_ value: ExchangeError) -> RustBuffer {
    return FfiConverterTypeExchangeError.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * All response status codes
 * gemSpec_COS_3.14.0#16.2
 */

public enum HealthCardResponseStatus: Equatable, Hashable {
    
    case success
    case unknownException
    case unknownStatus
    case dataTruncated
    case corruptDataWarning
    case endOfFileWarning
    case endOfRecordWarning
    case unsuccessfulSearch
    case fileDeactivated
    case fileTerminated
    case recordDeactivated
    case transportStatusTransportPin
    case transportStatusEmptyPin
    case passwordDisabled
    case authenticationFailure
    case noAuthentication
    case retryCounterCount00
    case retryCounterCount01
    case retryCounterCount02
    case retryCounterCount03
    case retryCounterCount04
    case retryCounterCount05
    case retryCounterCount06
    case retryCounterCount07
    case retryCounterCount08
    case retryCounterCount09
    case retryCounterCount10
    case retryCounterCount11
    case retryCounterCount12
    case retryCounterCount13
    case retryCounterCount14
    case retryCounterCount15
    case updateRetryWarningCount00
    case updateRetryWarningCount01
    case updateRetryWarningCount02
    case updateRetryWarningCount03
    case updateRetryWarningCount04
    case updateRetryWarningCount05
    case updateRetryWarningCount06
    case updateRetryWarningCount07
    case updateRetryWarningCount08
    case updateRetryWarningCount09
    case updateRetryWarningCount10
    case updateRetryWarningCount11
    case updateRetryWarningCount12
    case updateRetryWarningCount13
    case updateRetryWarningCount14
    case updateRetryWarningCount15
    case wrongSecretWarningCount00
    case wrongSecretWarningCount01
    case wrongSecretWarningCount02
    case wrongSecretWarningCount03
    case wrongSecretWarningCount04
    case wrongSecretWarningCount05
    case wrongSecretWarningCount06
    case wrongSecretWarningCount07
    case wrongSecretWarningCount08
    case wrongSecretWarningCount09
    case wrongSecretWarningCount10
    case wrongSecretWarningCount11
    case wrongSecretWarningCount12
    case wrongSecretWarningCount13
    case wrongSecretWarningCount14
    case wrongSecretWarningCount15
    case encipherError
    case keyInvalid
    case objectTerminated
    case parameterMismatch
    case memoryFailure
    case wrongRecordLength
    case channelClosed
    case noMoreChannelsAvailable
    case volatileKeyWithoutLcs
    case wrongFileType
    case securityStatusNotSatisfied
    case commandBlocked
    case keyExpired
    case passwordBlocked
    case keyAlreadyPresent
    case noKeyReference
    case noPrkReference
    case noPukReference
    case noRandom
    case noRecordLifeCycleStatus
    case passwordNotUsable
    case wrongRandomLength
    case wrongRandomOrNoKeyReference
    case wrongPasswordLength
    case noCurrentEf
    case incorrectSmDo
    case newFileSizeWrong
    case numberPreconditionWrong
    case numberScenarioWrong
    case verificationError
    case wrongCipherText
    case wrongToken
    case unsupportedFunction
    case fileNotFound
    case recordNotFound
    case dataTooBig
    case fullRecordList
    case messageTooLong
    case outOfMemory
    case inconsistentKeyReference
    case wrongKeyReference
    case keyNotFound
    case keyOrPrkNotFound
    case passwordNotFound
    case prkNotFound
    case pukNotFound
    case duplicatedObjects
    case dfNameExists
    case offsetTooBig
    case instructionNotSupported
    case pukBlocked



}

#if compiler(>=6)
extension HealthCardResponseStatus: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHealthCardResponseStatus: FfiConverterRustBuffer {
    typealias SwiftType = HealthCardResponseStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HealthCardResponseStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .success
        
        case 2: return .unknownException
        
        case 3: return .unknownStatus
        
        case 4: return .dataTruncated
        
        case 5: return .corruptDataWarning
        
        case 6: return .endOfFileWarning
        
        case 7: return .endOfRecordWarning
        
        case 8: return .unsuccessfulSearch
        
        case 9: return .fileDeactivated
        
        case 10: return .fileTerminated
        
        case 11: return .recordDeactivated
        
        case 12: return .transportStatusTransportPin
        
        case 13: return .transportStatusEmptyPin
        
        case 14: return .passwordDisabled
        
        case 15: return .authenticationFailure
        
        case 16: return .noAuthentication
        
        case 17: return .retryCounterCount00
        
        case 18: return .retryCounterCount01
        
        case 19: return .retryCounterCount02
        
        case 20: return .retryCounterCount03
        
        case 21: return .retryCounterCount04
        
        case 22: return .retryCounterCount05
        
        case 23: return .retryCounterCount06
        
        case 24: return .retryCounterCount07
        
        case 25: return .retryCounterCount08
        
        case 26: return .retryCounterCount09
        
        case 27: return .retryCounterCount10
        
        case 28: return .retryCounterCount11
        
        case 29: return .retryCounterCount12
        
        case 30: return .retryCounterCount13
        
        case 31: return .retryCounterCount14
        
        case 32: return .retryCounterCount15
        
        case 33: return .updateRetryWarningCount00
        
        case 34: return .updateRetryWarningCount01
        
        case 35: return .updateRetryWarningCount02
        
        case 36: return .updateRetryWarningCount03
        
        case 37: return .updateRetryWarningCount04
        
        case 38: return .updateRetryWarningCount05
        
        case 39: return .updateRetryWarningCount06
        
        case 40: return .updateRetryWarningCount07
        
        case 41: return .updateRetryWarningCount08
        
        case 42: return .updateRetryWarningCount09
        
        case 43: return .updateRetryWarningCount10
        
        case 44: return .updateRetryWarningCount11
        
        case 45: return .updateRetryWarningCount12
        
        case 46: return .updateRetryWarningCount13
        
        case 47: return .updateRetryWarningCount14
        
        case 48: return .updateRetryWarningCount15
        
        case 49: return .wrongSecretWarningCount00
        
        case 50: return .wrongSecretWarningCount01
        
        case 51: return .wrongSecretWarningCount02
        
        case 52: return .wrongSecretWarningCount03
        
        case 53: return .wrongSecretWarningCount04
        
        case 54: return .wrongSecretWarningCount05
        
        case 55: return .wrongSecretWarningCount06
        
        case 56: return .wrongSecretWarningCount07
        
        case 57: return .wrongSecretWarningCount08
        
        case 58: return .wrongSecretWarningCount09
        
        case 59: return .wrongSecretWarningCount10
        
        case 60: return .wrongSecretWarningCount11
        
        case 61: return .wrongSecretWarningCount12
        
        case 62: return .wrongSecretWarningCount13
        
        case 63: return .wrongSecretWarningCount14
        
        case 64: return .wrongSecretWarningCount15
        
        case 65: return .encipherError
        
        case 66: return .keyInvalid
        
        case 67: return .objectTerminated
        
        case 68: return .parameterMismatch
        
        case 69: return .memoryFailure
        
        case 70: return .wrongRecordLength
        
        case 71: return .channelClosed
        
        case 72: return .noMoreChannelsAvailable
        
        case 73: return .volatileKeyWithoutLcs
        
        case 74: return .wrongFileType
        
        case 75: return .securityStatusNotSatisfied
        
        case 76: return .commandBlocked
        
        case 77: return .keyExpired
        
        case 78: return .passwordBlocked
        
        case 79: return .keyAlreadyPresent
        
        case 80: return .noKeyReference
        
        case 81: return .noPrkReference
        
        case 82: return .noPukReference
        
        case 83: return .noRandom
        
        case 84: return .noRecordLifeCycleStatus
        
        case 85: return .passwordNotUsable
        
        case 86: return .wrongRandomLength
        
        case 87: return .wrongRandomOrNoKeyReference
        
        case 88: return .wrongPasswordLength
        
        case 89: return .noCurrentEf
        
        case 90: return .incorrectSmDo
        
        case 91: return .newFileSizeWrong
        
        case 92: return .numberPreconditionWrong
        
        case 93: return .numberScenarioWrong
        
        case 94: return .verificationError
        
        case 95: return .wrongCipherText
        
        case 96: return .wrongToken
        
        case 97: return .unsupportedFunction
        
        case 98: return .fileNotFound
        
        case 99: return .recordNotFound
        
        case 100: return .dataTooBig
        
        case 101: return .fullRecordList
        
        case 102: return .messageTooLong
        
        case 103: return .outOfMemory
        
        case 104: return .inconsistentKeyReference
        
        case 105: return .wrongKeyReference
        
        case 106: return .keyNotFound
        
        case 107: return .keyOrPrkNotFound
        
        case 108: return .passwordNotFound
        
        case 109: return .prkNotFound
        
        case 110: return .pukNotFound
        
        case 111: return .duplicatedObjects
        
        case 112: return .dfNameExists
        
        case 113: return .offsetTooBig
        
        case 114: return .instructionNotSupported
        
        case 115: return .pukBlocked
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: HealthCardResponseStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .success:
            writeInt(&buf, Int32(1))
        
        
        case .unknownException:
            writeInt(&buf, Int32(2))
        
        
        case .unknownStatus:
            writeInt(&buf, Int32(3))
        
        
        case .dataTruncated:
            writeInt(&buf, Int32(4))
        
        
        case .corruptDataWarning:
            writeInt(&buf, Int32(5))
        
        
        case .endOfFileWarning:
            writeInt(&buf, Int32(6))
        
        
        case .endOfRecordWarning:
            writeInt(&buf, Int32(7))
        
        
        case .unsuccessfulSearch:
            writeInt(&buf, Int32(8))
        
        
        case .fileDeactivated:
            writeInt(&buf, Int32(9))
        
        
        case .fileTerminated:
            writeInt(&buf, Int32(10))
        
        
        case .recordDeactivated:
            writeInt(&buf, Int32(11))
        
        
        case .transportStatusTransportPin:
            writeInt(&buf, Int32(12))
        
        
        case .transportStatusEmptyPin:
            writeInt(&buf, Int32(13))
        
        
        case .passwordDisabled:
            writeInt(&buf, Int32(14))
        
        
        case .authenticationFailure:
            writeInt(&buf, Int32(15))
        
        
        case .noAuthentication:
            writeInt(&buf, Int32(16))
        
        
        case .retryCounterCount00:
            writeInt(&buf, Int32(17))
        
        
        case .retryCounterCount01:
            writeInt(&buf, Int32(18))
        
        
        case .retryCounterCount02:
            writeInt(&buf, Int32(19))
        
        
        case .retryCounterCount03:
            writeInt(&buf, Int32(20))
        
        
        case .retryCounterCount04:
            writeInt(&buf, Int32(21))
        
        
        case .retryCounterCount05:
            writeInt(&buf, Int32(22))
        
        
        case .retryCounterCount06:
            writeInt(&buf, Int32(23))
        
        
        case .retryCounterCount07:
            writeInt(&buf, Int32(24))
        
        
        case .retryCounterCount08:
            writeInt(&buf, Int32(25))
        
        
        case .retryCounterCount09:
            writeInt(&buf, Int32(26))
        
        
        case .retryCounterCount10:
            writeInt(&buf, Int32(27))
        
        
        case .retryCounterCount11:
            writeInt(&buf, Int32(28))
        
        
        case .retryCounterCount12:
            writeInt(&buf, Int32(29))
        
        
        case .retryCounterCount13:
            writeInt(&buf, Int32(30))
        
        
        case .retryCounterCount14:
            writeInt(&buf, Int32(31))
        
        
        case .retryCounterCount15:
            writeInt(&buf, Int32(32))
        
        
        case .updateRetryWarningCount00:
            writeInt(&buf, Int32(33))
        
        
        case .updateRetryWarningCount01:
            writeInt(&buf, Int32(34))
        
        
        case .updateRetryWarningCount02:
            writeInt(&buf, Int32(35))
        
        
        case .updateRetryWarningCount03:
            writeInt(&buf, Int32(36))
        
        
        case .updateRetryWarningCount04:
            writeInt(&buf, Int32(37))
        
        
        case .updateRetryWarningCount05:
            writeInt(&buf, Int32(38))
        
        
        case .updateRetryWarningCount06:
            writeInt(&buf, Int32(39))
        
        
        case .updateRetryWarningCount07:
            writeInt(&buf, Int32(40))
        
        
        case .updateRetryWarningCount08:
            writeInt(&buf, Int32(41))
        
        
        case .updateRetryWarningCount09:
            writeInt(&buf, Int32(42))
        
        
        case .updateRetryWarningCount10:
            writeInt(&buf, Int32(43))
        
        
        case .updateRetryWarningCount11:
            writeInt(&buf, Int32(44))
        
        
        case .updateRetryWarningCount12:
            writeInt(&buf, Int32(45))
        
        
        case .updateRetryWarningCount13:
            writeInt(&buf, Int32(46))
        
        
        case .updateRetryWarningCount14:
            writeInt(&buf, Int32(47))
        
        
        case .updateRetryWarningCount15:
            writeInt(&buf, Int32(48))
        
        
        case .wrongSecretWarningCount00:
            writeInt(&buf, Int32(49))
        
        
        case .wrongSecretWarningCount01:
            writeInt(&buf, Int32(50))
        
        
        case .wrongSecretWarningCount02:
            writeInt(&buf, Int32(51))
        
        
        case .wrongSecretWarningCount03:
            writeInt(&buf, Int32(52))
        
        
        case .wrongSecretWarningCount04:
            writeInt(&buf, Int32(53))
        
        
        case .wrongSecretWarningCount05:
            writeInt(&buf, Int32(54))
        
        
        case .wrongSecretWarningCount06:
            writeInt(&buf, Int32(55))
        
        
        case .wrongSecretWarningCount07:
            writeInt(&buf, Int32(56))
        
        
        case .wrongSecretWarningCount08:
            writeInt(&buf, Int32(57))
        
        
        case .wrongSecretWarningCount09:
            writeInt(&buf, Int32(58))
        
        
        case .wrongSecretWarningCount10:
            writeInt(&buf, Int32(59))
        
        
        case .wrongSecretWarningCount11:
            writeInt(&buf, Int32(60))
        
        
        case .wrongSecretWarningCount12:
            writeInt(&buf, Int32(61))
        
        
        case .wrongSecretWarningCount13:
            writeInt(&buf, Int32(62))
        
        
        case .wrongSecretWarningCount14:
            writeInt(&buf, Int32(63))
        
        
        case .wrongSecretWarningCount15:
            writeInt(&buf, Int32(64))
        
        
        case .encipherError:
            writeInt(&buf, Int32(65))
        
        
        case .keyInvalid:
            writeInt(&buf, Int32(66))
        
        
        case .objectTerminated:
            writeInt(&buf, Int32(67))
        
        
        case .parameterMismatch:
            writeInt(&buf, Int32(68))
        
        
        case .memoryFailure:
            writeInt(&buf, Int32(69))
        
        
        case .wrongRecordLength:
            writeInt(&buf, Int32(70))
        
        
        case .channelClosed:
            writeInt(&buf, Int32(71))
        
        
        case .noMoreChannelsAvailable:
            writeInt(&buf, Int32(72))
        
        
        case .volatileKeyWithoutLcs:
            writeInt(&buf, Int32(73))
        
        
        case .wrongFileType:
            writeInt(&buf, Int32(74))
        
        
        case .securityStatusNotSatisfied:
            writeInt(&buf, Int32(75))
        
        
        case .commandBlocked:
            writeInt(&buf, Int32(76))
        
        
        case .keyExpired:
            writeInt(&buf, Int32(77))
        
        
        case .passwordBlocked:
            writeInt(&buf, Int32(78))
        
        
        case .keyAlreadyPresent:
            writeInt(&buf, Int32(79))
        
        
        case .noKeyReference:
            writeInt(&buf, Int32(80))
        
        
        case .noPrkReference:
            writeInt(&buf, Int32(81))
        
        
        case .noPukReference:
            writeInt(&buf, Int32(82))
        
        
        case .noRandom:
            writeInt(&buf, Int32(83))
        
        
        case .noRecordLifeCycleStatus:
            writeInt(&buf, Int32(84))
        
        
        case .passwordNotUsable:
            writeInt(&buf, Int32(85))
        
        
        case .wrongRandomLength:
            writeInt(&buf, Int32(86))
        
        
        case .wrongRandomOrNoKeyReference:
            writeInt(&buf, Int32(87))
        
        
        case .wrongPasswordLength:
            writeInt(&buf, Int32(88))
        
        
        case .noCurrentEf:
            writeInt(&buf, Int32(89))
        
        
        case .incorrectSmDo:
            writeInt(&buf, Int32(90))
        
        
        case .newFileSizeWrong:
            writeInt(&buf, Int32(91))
        
        
        case .numberPreconditionWrong:
            writeInt(&buf, Int32(92))
        
        
        case .numberScenarioWrong:
            writeInt(&buf, Int32(93))
        
        
        case .verificationError:
            writeInt(&buf, Int32(94))
        
        
        case .wrongCipherText:
            writeInt(&buf, Int32(95))
        
        
        case .wrongToken:
            writeInt(&buf, Int32(96))
        
        
        case .unsupportedFunction:
            writeInt(&buf, Int32(97))
        
        
        case .fileNotFound:
            writeInt(&buf, Int32(98))
        
        
        case .recordNotFound:
            writeInt(&buf, Int32(99))
        
        
        case .dataTooBig:
            writeInt(&buf, Int32(100))
        
        
        case .fullRecordList:
            writeInt(&buf, Int32(101))
        
        
        case .messageTooLong:
            writeInt(&buf, Int32(102))
        
        
        case .outOfMemory:
            writeInt(&buf, Int32(103))
        
        
        case .inconsistentKeyReference:
            writeInt(&buf, Int32(104))
        
        
        case .wrongKeyReference:
            writeInt(&buf, Int32(105))
        
        
        case .keyNotFound:
            writeInt(&buf, Int32(106))
        
        
        case .keyOrPrkNotFound:
            writeInt(&buf, Int32(107))
        
        
        case .passwordNotFound:
            writeInt(&buf, Int32(108))
        
        
        case .prkNotFound:
            writeInt(&buf, Int32(109))
        
        
        case .pukNotFound:
            writeInt(&buf, Int32(110))
        
        
        case .duplicatedObjects:
            writeInt(&buf, Int32(111))
        
        
        case .dfNameExists:
            writeInt(&buf, Int32(112))
        
        
        case .offsetTooBig:
            writeInt(&buf, Int32(113))
        
        
        case .instructionNotSupported:
            writeInt(&buf, Int32(114))
        
        
        case .pukBlocked:
            writeInt(&buf, Int32(115))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHealthCardResponseStatus_lift(_ buf: RustBuffer) throws -> HealthCardResponseStatus {
    return try FfiConverterTypeHealthCardResponseStatus.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHealthCardResponseStatus_lower(_ value: HealthCardResponseStatus) -> RustBuffer {
    return FfiConverterTypeHealthCardResponseStatus.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Indicates whether an APDU uses short (1-byte length fields) or extended (3-byte) encoding.
 */

public enum LengthClass: Equatable, Hashable {
    
    case short
    case extended



}

#if compiler(>=6)
extension LengthClass: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLengthClass: FfiConverterRustBuffer {
    typealias SwiftType = LengthClass

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LengthClass {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .short
        
        case 2: return .extended
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LengthClass, into buf: inout [UInt8]) {
        switch value {
        
        
        case .short:
            writeInt(&buf, Int32(1))
        
        
        case .extended:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLengthClass_lift(_ buf: RustBuffer) throws -> LengthClass {
    return try FfiConverterTypeLengthClass.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLengthClass_lower(_ value: LengthClass) -> RustBuffer {
    return FfiConverterTypeLengthClass.lower(value)
}



/**
 * UniFFI error type for secure-channel operations.
 *
 * This maps core `ExchangeError`/`SecureChannelError` into an FFI-friendly representation.
 */
public enum SecureChannelError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    case Transport(code: UInt32, reason: String
    )
    case UnexpectedStatus(status: HealthCardResponseStatus
    )
    case Status(status: HealthCardResponseStatus
    )
    case PaceInfo(reason: String
    )
    case Crypto(error: String
    )
    case Asn1Decode(reason: String
    )
    case Asn1Encode(reason: String
    )
    case GeneralAuthenticateCommand(reason: String
    )
    case ManageSecurityEnvironmentCommand(reason: String
    )
    case Command(reason: String
    )
    case PinBlock(reason: String
    )
    case InvalidCardVersion
    case InvalidArgument(reason: String
    )
    case MutualAuthenticationFailed
    case Apdu(error: ApduError
    )

    

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension SecureChannelError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSecureChannelError: FfiConverterRustBuffer {
    typealias SwiftType = SecureChannelError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecureChannelError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Transport(
            code: try FfiConverterUInt32.read(from: &buf), 
            reason: try FfiConverterString.read(from: &buf)
            )
        case 2: return .UnexpectedStatus(
            status: try FfiConverterTypeHealthCardResponseStatus.read(from: &buf)
            )
        case 3: return .Status(
            status: try FfiConverterTypeHealthCardResponseStatus.read(from: &buf)
            )
        case 4: return .PaceInfo(
            reason: try FfiConverterString.read(from: &buf)
            )
        case 5: return .Crypto(
            error: try FfiConverterString.read(from: &buf)
            )
        case 6: return .Asn1Decode(
            reason: try FfiConverterString.read(from: &buf)
            )
        case 7: return .Asn1Encode(
            reason: try FfiConverterString.read(from: &buf)
            )
        case 8: return .GeneralAuthenticateCommand(
            reason: try FfiConverterString.read(from: &buf)
            )
        case 9: return .ManageSecurityEnvironmentCommand(
            reason: try FfiConverterString.read(from: &buf)
            )
        case 10: return .Command(
            reason: try FfiConverterString.read(from: &buf)
            )
        case 11: return .PinBlock(
            reason: try FfiConverterString.read(from: &buf)
            )
        case 12: return .InvalidCardVersion
        case 13: return .InvalidArgument(
            reason: try FfiConverterString.read(from: &buf)
            )
        case 14: return .MutualAuthenticationFailed
        case 15: return .Apdu(
            error: try FfiConverterTypeApduError.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SecureChannelError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Transport(code,reason):
            writeInt(&buf, Int32(1))
            FfiConverterUInt32.write(code, into: &buf)
            FfiConverterString.write(reason, into: &buf)
            
        
        case let .UnexpectedStatus(status):
            writeInt(&buf, Int32(2))
            FfiConverterTypeHealthCardResponseStatus.write(status, into: &buf)
            
        
        case let .Status(status):
            writeInt(&buf, Int32(3))
            FfiConverterTypeHealthCardResponseStatus.write(status, into: &buf)
            
        
        case let .PaceInfo(reason):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(reason, into: &buf)
            
        
        case let .Crypto(error):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(error, into: &buf)
            
        
        case let .Asn1Decode(reason):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(reason, into: &buf)
            
        
        case let .Asn1Encode(reason):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(reason, into: &buf)
            
        
        case let .GeneralAuthenticateCommand(reason):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(reason, into: &buf)
            
        
        case let .ManageSecurityEnvironmentCommand(reason):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(reason, into: &buf)
            
        
        case let .Command(reason):
            writeInt(&buf, Int32(10))
            FfiConverterString.write(reason, into: &buf)
            
        
        case let .PinBlock(reason):
            writeInt(&buf, Int32(11))
            FfiConverterString.write(reason, into: &buf)
            
        
        case .InvalidCardVersion:
            writeInt(&buf, Int32(12))
        
        
        case let .InvalidArgument(reason):
            writeInt(&buf, Int32(13))
            FfiConverterString.write(reason, into: &buf)
            
        
        case .MutualAuthenticationFailed:
            writeInt(&buf, Int32(14))
        
        
        case let .Apdu(error):
            writeInt(&buf, Int32(15))
            FfiConverterTypeApduError.write(error, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecureChannelError_lift(_ buf: RustBuffer) throws -> SecureChannelError {
    return try FfiConverterTypeSecureChannelError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecureChannelError_lower(_ value: SecureChannelError) -> RustBuffer {
    return FfiConverterTypeSecureChannelError.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * High-level outcome of a PIN verification attempt.
 */

public enum VerifyPinOutcome: Equatable, Hashable {
    
    case success
    case wrongSecretWarning
    case cardBlocked



}

#if compiler(>=6)
extension VerifyPinOutcome: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeVerifyPinOutcome: FfiConverterRustBuffer {
    typealias SwiftType = VerifyPinOutcome

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VerifyPinOutcome {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .success
        
        case 2: return .wrongSecretWarning
        
        case 3: return .cardBlocked
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: VerifyPinOutcome, into buf: inout [UInt8]) {
        switch value {
        
        
        case .success:
            writeInt(&buf, Int32(1))
        
        
        case .wrongSecretWarning:
            writeInt(&buf, Int32(2))
        
        
        case .cardBlocked:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVerifyPinOutcome_lift(_ buf: RustBuffer) throws -> VerifyPinOutcome {
    return try FfiConverterTypeVerifyPinOutcome.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVerifyPinOutcome_lower(_ value: VerifyPinOutcome) -> RustBuffer {
    return FfiConverterTypeVerifyPinOutcome.lower(value)
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionUInt8: FfiConverterRustBuffer {
    typealias SwiftType = UInt8?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt8.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt8.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}
/**
 * Changes the home PIN using the old PIN.
 */
public func changePin(session: CardChannel, oldPin: CardPin, newPin: CardPin)throws  -> HealthCardResponseStatus  {
    return try  FfiConverterTypeHealthCardResponseStatus_lift(try rustCallWithError(FfiConverterTypeExchangeError_lift) {
    uniffi_healthcard_fn_func_change_pin(
        FfiConverterTypeCardChannel_lower(session),
        FfiConverterTypeCardPin_lower(oldPin),
        FfiConverterTypeCardPin_lower(newPin),$0
    )
})
}
/**
 * Changes the home PIN using the PUK (reset retry counter + new PIN).
 */
public func changePinWithPuk(session: CardChannel, puk: CardPin, newPin: CardPin)throws  -> HealthCardResponseStatus  {
    return try  FfiConverterTypeHealthCardResponseStatus_lift(try rustCallWithError(FfiConverterTypeExchangeError_lift) {
    uniffi_healthcard_fn_func_change_pin_with_puk(
        FfiConverterTypeCardChannel_lower(session),
        FfiConverterTypeCardPin_lower(puk),
        FfiConverterTypeCardPin_lower(newPin),$0
    )
})
}
/**
 * Establishes a secure channel (PACE) over the given card session.
 *
 * The returned `SecureChannel` can be used to transmit protected APDUs and to call higher-level
 * operations (PIN verify, certificate retrieval, etc.) with secure messaging.
 */
public func establishSecureChannel(session: CardChannel, cardAccessNumber: CardAccessNumber)throws  -> SecureChannel  {
    return try  FfiConverterTypeSecureChannel_lift(try rustCallWithError(FfiConverterTypeSecureChannelError_lift) {
    uniffi_healthcard_fn_func_establish_secure_channel(
        FfiConverterTypeCardChannel_lower(session),
        FfiConverterTypeCardAccessNumber_lower(cardAccessNumber),$0
    )
})
}
/**
 * Establishes a secure channel (PACE) using deterministic private keys.
 *
 * The `keys` input must contain at least two hex-encoded private keys which are used
 * in order during PACE establishment. This is intended for transcript replay tests.
 */
public func establishSecureChannelWithKeys(session: CardChannel, cardAccessNumber: CardAccessNumber, keys: [String])throws  -> SecureChannel  {
    return try  FfiConverterTypeSecureChannel_lift(try rustCallWithError(FfiConverterTypeSecureChannelError_lift) {
    uniffi_healthcard_fn_func_establish_secure_channel_with_keys(
        FfiConverterTypeCardChannel_lower(session),
        FfiConverterTypeCardAccessNumber_lower(cardAccessNumber),
        FfiConverterSequenceString.lower(keys),$0
    )
})
}
/**
 * Returns `length` bytes of random data from the card.
 */
public func getRandom(session: CardChannel, length: UInt32)throws  -> Data  {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypeExchangeError_lift) {
    uniffi_healthcard_fn_func_get_random(
        FfiConverterTypeCardChannel_lower(session),
        FfiConverterUInt32.lower(length),$0
    )
})
}
/**
 * Reads the VSD container from the card (if available).
 */
public func readVsd(session: CardChannel)throws  -> Data  {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypeExchangeError_lift) {
    uniffi_healthcard_fn_func_read_vsd(
        FfiConverterTypeCardChannel_lower(session),$0
    )
})
}
/**
 * Retrieves the default certificate from the card.
 */
public func retrieveCertificate(session: CardChannel)throws  -> Data  {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypeExchangeError_lift) {
    uniffi_healthcard_fn_func_retrieve_certificate(
        FfiConverterTypeCardChannel_lower(session),$0
    )
})
}
/**
 * Retrieves a specific certificate file from the card.
 */
public func retrieveCertificateFrom(session: CardChannel, certificate: CertificateFile)throws  -> Data  {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypeExchangeError_lift) {
    uniffi_healthcard_fn_func_retrieve_certificate_from(
        FfiConverterTypeCardChannel_lower(session),
        FfiConverterTypeCertificateFile_lower(certificate),$0
    )
})
}
/**
 * Signs the given challenge with the card's signing key.
 */
public func signChallenge(session: CardChannel, challenge: Data)throws  -> Data  {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypeExchangeError_lift) {
    uniffi_healthcard_fn_func_sign_challenge(
        FfiConverterTypeCardChannel_lower(session),
        FfiConverterData.lower(challenge),$0
    )
})
}
/**
 * Unlocks the home PIN using the PUK (reset retry counter).
 */
public func unlockEgkWithPuk(session: CardChannel, puk: CardPin)throws  -> HealthCardResponseStatus  {
    return try  FfiConverterTypeHealthCardResponseStatus_lift(try rustCallWithError(FfiConverterTypeExchangeError_lift) {
    uniffi_healthcard_fn_func_unlock_egk_with_puk(
        FfiConverterTypeCardChannel_lower(session),
        FfiConverterTypeCardPin_lower(puk),$0
    )
})
}
/**
 * Verifies a PIN against the card.
 *
 * This is a stateless helper that performs the necessary APDU exchange(s) on the provided
 * `session`. For workflows that require PACE/secure messaging, use `secure_channel` APIs.
 */
public func verifyPin(session: CardChannel, pin: CardPin)throws  -> VerifyPinResult  {
    return try  FfiConverterTypeVerifyPinResult_lift(try rustCallWithError(FfiConverterTypeExchangeError_lift) {
    uniffi_healthcard_fn_func_verify_pin(
        FfiConverterTypeCardChannel_lower(session),
        FfiConverterTypeCardPin_lower(pin),$0
    )
})
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private let initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 30
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_healthcard_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_healthcard_checksum_func_change_pin() != 40798) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_healthcard_checksum_func_change_pin_with_puk() != 29979) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_healthcard_checksum_func_establish_secure_channel() != 21369) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_healthcard_checksum_func_establish_secure_channel_with_keys() != 33081) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_healthcard_checksum_func_get_random() != 16723) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_healthcard_checksum_func_read_vsd() != 42139) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_healthcard_checksum_func_retrieve_certificate() != 34830) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_healthcard_checksum_func_retrieve_certificate_from() != 47881) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_healthcard_checksum_func_sign_challenge() != 47552) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_healthcard_checksum_func_unlock_egk_with_puk() != 5064) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_healthcard_checksum_func_verify_pin() != 3049) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_healthcard_checksum_method_cardaccessnumber_digits() != 5519) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_healthcard_checksum_method_cardchannel_supports_extended_length() != 40476) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_healthcard_checksum_method_cardchannel_transmit() != 32732) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_healthcard_checksum_method_commandapdu_to_bytes() != 20882) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_healthcard_checksum_method_responseapdu_data() != 37789) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_healthcard_checksum_method_responseapdu_sw() != 50881) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_healthcard_checksum_method_responseapdu_to_bytes() != 64047) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_healthcard_checksum_method_securechannel_change_pin() != 1568) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_healthcard_checksum_method_securechannel_change_pin_with_puk() != 14667) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_healthcard_checksum_method_securechannel_get_random() != 16206) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_healthcard_checksum_method_securechannel_read_vsd() != 7414) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_healthcard_checksum_method_securechannel_retrieve_certificate() != 32480) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_healthcard_checksum_method_securechannel_retrieve_certificate_from() != 21272) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_healthcard_checksum_method_securechannel_sign_challenge() != 56105) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_healthcard_checksum_method_securechannel_supports_extended_length() != 45098) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_healthcard_checksum_method_securechannel_transmit() != 45890) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_healthcard_checksum_method_securechannel_unlock_egk_with_puk() != 10296) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_healthcard_checksum_method_securechannel_verify_pin() != 3440) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_healthcard_checksum_constructor_cardaccessnumber_from_digits() != 28176) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_healthcard_checksum_constructor_cardpin_from_digits() != 42590) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_healthcard_checksum_constructor_commandapdu_from_bytes() != 38240) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_healthcard_checksum_constructor_commandapdu_header_only() != 12577) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_healthcard_checksum_constructor_commandapdu_with_data() != 28989) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_healthcard_checksum_constructor_commandapdu_with_data_and_expect() != 63577) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_healthcard_checksum_constructor_commandapdu_with_expect() != 12035) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_healthcard_checksum_constructor_responseapdu_from_bytes() != 58928) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_healthcard_checksum_constructor_responseapdu_from_parts() != 45772) {
        return InitializationResult.apiChecksumMismatch
    }

    uniffiCallbackInitCardChannel()
    return InitializationResult.ok
}()

// Make the ensure init function public so that other modules which have external type references to
// our types can call it.
public func uniffiEnsureHealthcardInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all