// Copyright 2025 gematik GmbH
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef OH_MLKEM_HPP
#define OH_MLKEM_HPP

#include "capi.hpp"
#include "types.hpp"

#include <openssl/evp.h>

namespace kem
{
using evp_pkey_ptr = ossl_unique_ptr(EVP_PKEY);

struct mlkem_encapsulation_data
{
    uint8_vector wrapped_key;
    uint8_vector shared_secret;
};

/**
 * @brief Represents the encapsulation functionality for ML-KEM (Key Encapsulation Mechanism).
 *
 * This class provides methods to create an encapsulation object and perform key encapsulation
 * in a cryptographic setting.
 */
class mlkem_encapsulation
{
    evp_pkey_ptr pkey;

    explicit mlkem_encapsulation(evp_pkey_ptr &&pkey);

  public:
    mlkem_encapsulation() = delete;

    /**
     * @brief Factory method to create a mlkem_encapsulation object.
     *
     * This creates and initializes a mlkem_encapsulation object
     * using the specified algorithm and encapsulation key.
     *
     * @param algorithm The name of the encapsulation algorithm to be used.
     * @param encapsulation_key The key used for encapsulation. Generated by a call to
     * mlkem_decapsulation::get_encapsulation_key.
     * @return An mlkem_encapsulation object.
     */
    static auto create(const std::string &algorithm, const uint8_vector &encapsulation_key)
        -> std::unique_ptr<mlkem_encapsulation>;

    /**
     * @brief Encapsulates a key and generates encapsulation data.
     *
     * This method performs the key encapsulation operation and returns the
     * encapsulation data, which can be used in mlkem_decapsulation::decapsulate.
     *
     * @return A mlkem_encapsulation_data object containing the encapsulation result.
     */
    [[nodiscard]] auto encapsulate() const -> mlkem_encapsulation_data;
};

/**
 * @brief Handles decapsulation operations for ML-KEM (Key Encapsulation Mechanism).
 *
 * This class provides methods to create a decapsulation object and perform key decapsulation
 * in a cryptographic setting.
 */
class mlkem_decapsulation
{
    evp_pkey_ptr pkey;

    explicit mlkem_decapsulation(evp_pkey_ptr &&pkey);

  public:
    mlkem_decapsulation() = delete;

    /**
     * @brief Factory method to create an mlkem_decapsulation instance.
     *
     * This creates and initializes a mlkem_decapsulation object
     * using the specified algorithm.
     *
     * @param algorithm The algorithm name for key encapsulation mechanism.
     * @return A mlkem_decapsulation instance.
     */
    static auto create(const std::string &algorithm) -> std::unique_ptr<mlkem_decapsulation>;

    static auto create_from_private_key(const std::string &algorithm, const uint8_vector &private_key)
        -> std::unique_ptr<mlkem_decapsulation>;

    /**
     * @brief Decapsulates the provided wrapped key to obtain the shared secret.
     *
     * This method performs the decapsulation process on the given wrapped key,
     * deriving the shared secret (unwrapped key) that was created during the encapsulation process.
     *
     * The shared secret must equal mlkem_encapsulation_data::shared_secret.
     *
     * @param wrapped_key The encapsulated key to decapsulate.
     * @return The shared secret.
     */
    [[nodiscard]] auto decapsulate(const uint8_vector &wrapped_key) const -> uint8_vector;

    /**
     * @brief Retrieves the encapsulation key.
     *
     * The encapsulation key is the public key or key material used in the encapsulation
     * process. This key is used in mlkem_encapsulation::create.
     *
     * @return The encapsulation key.
     */
    [[nodiscard]] auto get_encapsulation_key() const -> uint8_vector;
    [[nodiscard]] auto get_private_key() const -> uint8_vector;
};
} // namespace kem

#endif
